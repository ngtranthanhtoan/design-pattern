# Design Patterns Learning Repository - Cursor Rules

## Project Purpose
This is a comprehensive learning repository for Design Patterns with hands-on examples and practical implementations. The goal is to master design patterns through structured learning and real-world practice.

## Folder Structure Convention
- **Naming**: `[OrderNumber] - [Category] - [Pattern Name]`
- Example: `1 - Creational - Singleton`, `2 - Creational - Factory Method`

## Required Files per Pattern
1. **`introduction.md`** - Core concepts, theory, structure, benefits/drawbacks
2. **`use-case.md`** - Real-world applications, practical scenarios, best practices  
3. **`use-case-[specific-example].ts`** - Individual focused implementations
4. **`index.ts`** - Pattern overview and navigation with npm scripts

## Code Implementation Standards

### TypeScript Requirements
- Use proper TypeScript types and interfaces
- Include comprehensive error handling and edge cases
- Add `import { exit } from "process"` and `exit(0)` at end of runnable files
- Use modern ES6+ features and current best practices

### File Structure for Use Cases
```typescript
// 1. Interfaces and types first
// 2. Abstract classes/creators  
// 3. Concrete implementations
// 4. Usage examples with comprehensive testing
// 5. Demonstration functions
// 6. Export statements
```

### Content Quality Standards
- **Practical Examples**: Solve real-world problems, not toy examples
- **Runnable Code**: All examples must execute with `npm run` commands
- **Educational Value**: Include both usage and testing demonstrations  
- **Professional Quality**: Production-ready code with proper error handling
- **Comprehensive Comments**: Explain the "why" not just the "how"
- **Real-world Complexity**: Don't oversimplify, show actual implementation challenges

### Package.json Scripts Pattern
```json
{
  "[pattern]": "ts-node \"[folder]/index.ts\"",
  "[pattern]:[example1]": "ts-node \"[folder]/use-case-[example1].ts\"",
  "[pattern]:[example2]": "ts-node \"[folder]/use-case-[example2].ts\""
}
```

## Documentation Guidelines

### introduction.md Format
- What is the pattern?
- Key principles and structure  
- Benefits and drawbacks
- When to use/avoid
- UML diagrams or code structure examples
- Related patterns

### use-case.md Format  
- 5+ real-world implemented examples
- Each with Problem/Solution format
- Include actual API examples from implementations
- Industry use cases and modern alternatives
- Best practices and anti-patterns

### Code Comments Style
- Explain design pattern concepts being demonstrated
- Include reasoning for architectural decisions
- Document edge cases and error handling
- Reference pattern theory where applicable

## Reflection Articles

The `Reflection/` folder hosts in-depth comparative or theoretical articles (e.g. *factory-method-vs-abstract-factory.md*, *adapter-pattern-in-functional-programming.md*).

### Purpose
- Synthesize learnings across multiple patterns or paradigms
- Provide advanced conceptual explanations and trade-off analysis
- Serve as long-form reading material that complements runnable examples

### Structure Template
1. Executive summary / key-takeaways (optional)
2. Sub-sections with clear headings (e.g. *OO Perspective*, *Functional Perspective*, *Real-World Examples*)
3. Practical code snippets (TypeScript when possible) â€“ **no toy pseudo-code**
4. Comparison tables, UML or Mermaid diagrams where beneficial
5. "Best practices" and "Common pitfalls" sections
6. Further reading / references

### Writing Guidelines
- Keep a professional, instructional tone; favour clarity over jargon
- Back claims with concrete examples, metrics, or citations
- Show real-world APIs or libraries (Node core, express, fp-ts, etc.)
- Use fenced code blocks with language identifiers
- Keep line length reasonable (< 120 chars) to ease diffing
- Validate Mermaid diagrams compile in Markdown renderers

### Quality Checklist
- âœ… Includes at least **2-3 production-grade examples**
- âœ… Explains why each example matters in real projects
- âœ… Provides code that can be copy-pasted into repo or REPL
- âœ… Cross-links to related pattern folders where relevant
- âœ… Reviewed for technical accuracy and coherence

## Functional Patterns

Functional pattern folders live under `Function Patterns/` and demonstrate the FP equivalent of traditional OO design patterns.

### Folder Naming
- `Function Patterns/F[number] - [Pattern Name]`
- Example: `Function Patterns/F4 - Decorator Pattern - Function Composition`

### Required Files per FP Pattern
1. `index.ts` â€“ Pattern overview and runnable navigation (mirrors OO `index.ts` style)
2. `introduction.md` â€“ Functional theory, algebraic context, pros/cons, when to use/avoid
3. `use-case.md` â€“ 3â€“5 real-world implemented examples in Problem/Solution format
4. `use-case-[specific-example].ts` â€“ Focused runnable demos (may include multiple files)

### Coding Standards (FP-Specific)
- Prefer **pure functions** and **immutable data**; avoid classes unless interop is the lesson
- Use algebraic data types (`Option`, `Either`, `Task`, etc.) where they clarify intent
- Compose with `pipe` / `flow` (fp-ts) or native HOFs (`map`, `reduce`, `flatMap`)
- Document performance implications of composition when non-trivial
- Provide explicit types, `readonly` modifiers, and avoid `any`
- Demonstrate interop with Node/browser APIs when relevant (e.g. `promisify`, EventEmitterâ†’Promise)

### Package.json Script Pattern
```json
{
  "f[number]": "ts-node \"Function Patterns/F[number] - [Pattern Name]/index.ts\"",
  "f[number]:[example]": "ts-node \"Function Patterns/F[number] - [Pattern Name]/use-case-[example].ts\""
}
```

### Testing & Demonstrations
- Each `use-case-*.ts` shows both **usage** and **edge-case tests**
- Include at least one real API integration (filesystem, network, etc.) for pragmatic value
- Finish with `exit(0)` to align with runnable-script convention

### Quality Checklist
- âœ… Pure, side-effect-free core logic
- âœ… Demonstrates composition and reuse
- âœ… Clear, production-relevant examples (no toy hello-world)
- âœ… Thorough comments explaining FP concepts and trade-offs
- âœ… TypeScript compiles without `any`
- âœ… Scripts added to `package.json` following the pattern

## Implementation Approach

### When Creating New Patterns
1. Research real-world applications first
2. Start with simplest concrete example
3. Build complexity progressively across use cases
4. Each use case file should focus on ONE specific example
5. Include comprehensive testing within each file
6. Ensure all examples follow documented APIs exactly

### Learning Path Design
1. Basic example for pattern understanding
2. Intermediate examples showing variations
3. Advanced examples with real-world complexity
4. Integration examples showing pattern combinations

### Quality Checklist
- âœ… All code runs immediately with npm scripts
- âœ… TypeScript compilation without errors
- âœ… Comprehensive error handling included
- âœ… Real-world applicable examples
- âœ… Clear separation of concerns
- âœ… Modern best practices followed
- âœ… Educational comments throughout
- âœ… Testing/demonstration included

## Current Repository Status
- âœ… Singleton Pattern - Complete
- âœ… Factory Method Pattern - Complete and recently reworked
- ðŸ”„ Abstract Factory Pattern - In progress

## When Working on This Project
- Always create practical, immediately runnable examples
- Focus on real-world applicability over academic correctness
- Include multiple approaches to solve the same problem
- Ensure consistent API patterns across similar use cases
- Maintain modular design for focused learning
- Test everything thoroughly before considering complete

## Related Technologies
- TypeScript for type safety and modern JavaScript features
- Node.js for runtime environment
- npm scripts for easy example execution
- Comprehensive documentation in Markdown

This repository serves as both a learning resource and a reference for implementing design patterns in real TypeScript/JavaScript projects. 